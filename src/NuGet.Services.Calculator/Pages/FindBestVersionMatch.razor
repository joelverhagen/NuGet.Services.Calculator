@page "/find-best-version-match"
@using Microsoft.AspNetCore.WebUtilities
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject VersionRangeCalculator Service

<Title>Find Best Version Match - NuGet Calculator</Title>
<h1>Find Best Version Match</h1>

<EditForm EditContext="@_editContext" OnValidSubmit="HandleValidSubmitAsync">
    <div class="form-group">
        <label for="versionRange">Version Range</label>
        <InputText class="form-control" id="versionRange" placeholder="[1.0.0, )" @bind-Value="_input.VersionRange" />
        <ValidationMessage For="@(() => _input.VersionRange)" class="invalid-feedback" />
    </div>
    <div class="form-group">
        <label for="versions">Versions</label>
        <InputTextArea class="form-control" id="versions" placeholder="1.1.0" rows="5" @bind-Value="_input.Versions" />
        <ValidationMessage For="@(() => _input.Versions)" class="invalid-feedback" />
    </div>
    <div class="form-group">
        <button type="submit" class="btn btn-primary">Submit</button>
    </div>
</EditForm>

@if (_output != null && _output.InputStatus == InputStatus.Valid)
{
    if (_output.BestMatch != null)
    {
        <div class="alert alert-success" role="alert">
            The <code>@(_output.BestMatch.ToNormalizedString())</code> version is the best match to the
            <code>@_output.VersionRange.ToNormalizedString()</code> version range.
        </div>
    }
    else
    {
        <div class="alert alert-warning" role="alert">
            None of the versions satisfy the <code>@_output.VersionRange.ToNormalizedString()</code> version range.
        </div>
    }

    <div class="alert alert-info" role="alert">
        <p>The following versions were considered, <b>displayed in the order of precedence</b>:</p>
        <ol class="list-unstyled">
            @foreach (var input in _output.Versions)
            {
                <li>
                    @if (input.Satisfies)
                    {
                        <span class="oi oi-check" aria-hidden="true"></span>
                    }
                    else
                    {
                        <span class="oi oi-x" aria-hidden="true"></span>
                    }
                    <code>@input.Version.ToNormalizedString()</code>
                    @if (input.Satisfies)
                    {
                        @:satisfies
                    }
                    else
                    {
                        @:does not satisfy
                    }
                </li>
            }
        </ol>
    </div>
}

@code {
    private EditContext _editContext;
    private FindBestVersionMatchInput _input;
    private FindBestVersionMatchOutput _output;

    protected override void OnInitialized()
    {
        _input = new FindBestVersionMatchInput();
        _editContext = new EditContext(_input);
        _editContext.AddDataAnnotationsValidation();

        var currentUri = NavigationManager.ToAbsoluteUri(NavigationManager.Uri);
        var currentQuery = QueryHelpers.ParseQuery(currentUri.Query);

        if (currentQuery.TryGetValue("versionRange", out var versionRange))
        {
            _input.VersionRange = versionRange.First();
            _editContext.NotifyFieldChanged(_editContext.Field(nameof(FindBestVersionMatchInput.VersionRange)));
        }

        if (currentQuery.TryGetValue("versions", out var versions))
        {
            _input.Versions = versions.First();
            _editContext.NotifyFieldChanged(_editContext.Field(nameof(FindBestVersionMatchInput.Versions)));
        }

        if (_editContext.IsModified() && _editContext.Validate())
        {
            _output = Service.FindBestVersionMatch(_input);
        }
    }

    private async Task HandleValidSubmitAsync()
    {
        var localPath = new Uri(NavigationManager.Uri).LocalPath;
        var pathAndQuery = QueryHelpers.AddQueryString(localPath, new Dictionary<string, string>
        {
            { "versionRange", _input.VersionRange },
            { "versions", _input.Versions },
        });
        await JSRuntime.InvokeVoidAsync("history.replaceState", null, string.Empty, pathAndQuery);

        _output = Service.FindBestVersionMatch(_input);
    }
}